

Hierarchy 1 : A<S> <<< A<? extends S> <<< A<? extends T>
Example: Since Integer is a subtype of Number, List<Integer> is a subtype of List<? extends Integer> and List<? extends Integer> is a subtype of List<? extends Number>.
Thus, if an overridden method returns List<? extends Integer>, the overriding method can return List<Integer> but not List<Number> or List<? extends Number>.


Hierarchy 2 : A<T> <<< A<? super T> <<< A<? super S>
Example: List<Number> is a subtype of List<? super Number> and List<? super Number> is a subtype of List<? super Integer>
Thus, if an overridden method returns List<? super Number>, the overriding method can return List<Number> but not List<Integer> or List<? super Integer>.




It is important to understand that List<Integer> is not a subtype of List<Number> even though Integer is a subtype of Number. 





 Remember that methods of the java.lang.Object class do not count towards the number of abstract methods of an interface. So, for example, the following is still a valid functional interface even though it has three abstract method declarations:

@FunctionalInterface
public interface FI{
   int m1(); //valid abstract method
   boolean equals(Object o); //valid declaration
   //but does not count towards the number of abstract methods

   String toString(); //valid declaration
   //but does not count towards the number of abstract methods
}



add(e) is a queue method that adds the element to the end while push() is a stack method that adds the element to the front. Therefore, the contents of d change as follows:
1


