

Iterable<api.BloggerService> bsLoader = ServiceLoader.load(api.BloggerService.class);




LocalDateTime greatDay = LocalDateTime.parse("2022-01-01");
error


You must either specify the files that you want to compile or the module that you want to compile.
For compiling specific files, you have to simply list the files (without any option) and for compiling a module (i.e. all the files of a module), you have to use the --module (or -m) option.

java    c --module-source-path src -d out src/foo.bar/f/b/Baz1.java src/foo.bar/f/c/Caz1.java
or
javac --module-source-path src -d out --module foo.bar 




If the target already exists, Files.move() with ATOMIC_MOVE throws a FileAlreadyExistsException unless the file system supports replacing the existing file atomically.









“of”: Likely refers to Optional.of() (covered previously) or collection factory methods (List.of(), Set.of(), Map.of()). All reject null.
“collection”: The Collection interface is broad; focus on specific implementations like ConcurrentHashMap, TreeSet, or Collections.synchronizedX for null restrictions.
“Copy”: Interpreted as Files.copy(), which rejects null paths. If you meant something else (e.g., Collections.copy()), note that Collections.copy(List dest, List src) throws IndexOutOfBoundsException if dest is too small, but allows null elements if the underlying lists do.
“synchornized”: Likely refers to synchronized collections (Collections.synchronizedX) or classes like Vector, Hashtable. null behavior depends on the wrapped collection.
“Vector”: Unlike Hashtable, it allows null elements.


Files.copy/move(Path, Path): Reject null paths (NullPointerException).


ConcurrentHashMap: No null keys/values (NullPointerException).


ConcurrentLinkedQueue: May reject null in some methods (NullPointerException) in concurrent contexts.


CopyOnWriteArrayList allows null
All modification operations of a CopyOnWriteArrayList are considered atomic. So the thread that calls size() will either see no data in the list or will see all the elements added to the list.

It not thorws these exception: ConcurrentModificationException, CopyOnWriteArrayList but on  iterators themselves (remove, set, and add) are not supported. These methods throw UnsupportedOperationException


hashmap allows nulls




t LocalDateTime class does not contain Zone information but ISO_ZONED_DATE_TIME requires it. Thus, it will throw the following exception:

Exception in thread "main" java.time.temporal.UnsupportedTemporalTypeException:


 UnsupportedTemporalTypeException extends DateTimeException.





public static Duration between(Temporal startInclusive, Temporal endExclusive)

1. Duration.between method computes the duration between two temporal objects.  If the objects are of different types, then the duration is calculated based on the type of the first object. For example, if the first argument is a LocalTime then the second argument is converted to a LocalTime.

2. In this case, the difference between the two zones is 3 hours therefore the resulting duration will contain 3 hours.

3. The result of Duration.between method can be a negative period if the end is before the start.




  String str = "10";
Double.parseDouble(str); //valid // 10


setObject method in PreparedStatement
setObject(int parameterIndex, Object x)
setObject(int parameterIndex, Object x, int targetSqlType); Types.INTEGER
setObject(int parameterIndex, Object x, SQLType targetSqlType)
setObject(int parameterIndex, Object x, SQLType targetSqlType, int scaleOrLength);
setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength)


lic static Stream<Path> find(Path start, int maxDepth,
      BiPredicate<Path,BasicFileAttributes> matcher,
      FileVisitOption... options) throws IOException



no such method getDateInstance(Locale)



switch(value){
    case 1_000_000 -> {  //2
        System.out.println("A million 1");
        break; //3
    }
   ....
}

break redundant so no issue




AccessDeniedException exist

