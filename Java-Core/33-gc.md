
Garbage Collection
    1) Introduction
    2) The ways to make an object elegiible for gc\3( the mehtods for request jvm) to run gc
    3) The method for request for request jvm to run gc
    4) Finalisation

c++
    new
    delete

java
    new programmer
    gc to delete\

thats why java is robust

The ways to make an object eligible for gc
    object doesnt have any reference variable
    4 ways


Strudent s1 = new Student();
Student s2 = new Student();
// No object elegible ofr GC

s1 = null;
// one object eligible for gc
this approach is nullify reference variable



reassign
    Student s1 = new Student(), s2 = new Student();
    // no object eligible for GC
    s2 = new Student(); // one object eligible
    s2 = s1; // two object eligible
    



Object created inside method
    

Test
    m1(){
        Student s1 = new Student();
        Student s2 = new Student();}

after completeing method, no object are eligible for gc

object created inside method    




Student s3 = m1()
m1()
    Student s1 = new Student();
    Student s2 = new Student();
    return s1;
here only one elgible for gc




m1()
m1(){
    Student s1 = new Student();
    Student s2 = new Student();
    return s1;}
both eligible for gc


Island of isolation


static i;
p s v main(--[] args){
    Test r1 = new Test();
    Test r2 = new Test();
    Test r3 = new Test();

    r1.i = r2;
    r2.i = r3;
    r3.i = r1;

    r1 = null;
    r2 = null;
    r3 = null;
}

    this is island of isolation

like it is
 object doesnt contain any reference variable
 object contain referecne variable (all internal variable)


it dont kill immediately
it kills when jvm runs , some jvm runs at start some at end, etc


ways to request jvm to run gc:
    not guarantee but most of chance it will run
    
    1) By using system class
        System.gc();
        static mehtod
    2) by using  runtime class
        java program ask free memory
        it give
        then it ask total meory
        it give
        then gc
        Runtime r = Runtime.getRuntime();
        factory method


        1) r.totalMemory()
        2) r.freeMemory()
        3) r.gc(); // instance method


Runtime r= Runtime.getRuntime();
S.o.p(r.totalmemory()); // 100
S.o.p(r.freememory()); // 60
for (int i =0 ; i <= 10000; i++){
    Date d = new Date();
    d = null;
}
S.o.p(r.freememory());// 40
r.gcc();
S.o.p(r.freememory());// 30

internally jvm require some memory

there are many possibility, it not destroy, it partial destroy or all destroy


System.gc more appopriated
Runtime.gc();
(new Runtime).gc();
(Runtime.getRuntime()).gc(); // not valid


last wish of destroying object its: close all my connection
    .finalise()

it is one of 11 method of object
    protected void finalise throws Throwable()


finalization

p s v main(String[] args){
    String s = new String("string");
    s = null;
    System.gc();
    S.o.p("End of main")
}
public void finalize(){
    s.o.p("finalize method connect");
}
output
End of main

here string class finalize method will called




c Test{
p s v main(String[] args){
    Test s = new String("string");
    s = null;
    System.gc();
    S.o.p("End of main")
}
public void finalize(){
    s.o.p("finalize method connect");
}}


two method possibility
End of main
finalize method connect

finalize method connect
End of main


End of main

