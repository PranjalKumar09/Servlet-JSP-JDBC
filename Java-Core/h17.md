Although not recommended, it is possible to customize what packages a module exports from the command line.

If a module wants to read another module but only temporarily, it can request such access using command line options.


Modules allows a sealed class and its direct subtypes to be members of different packages.



Even packages that have not been exported in module-info can be made accessible using --add-exports command line option.


If a module does not export a package, there is  way to export that package to all other modules from the command line using --add-module


class modifier :
static allowed with no inner class
local class (inside method/block ) can be only abstract or final
anonymous is implicit final , so cant have final explicitly (\(no explicit modifiers like public, private, protected, static, abstract, final))


now insdier inner classes, 
    variable
        allowled: Access: public, protected, private, or default.
        Other: static, final, transient, volatile.


    static fields are only allowed in static nested classes, not in non-static inner, local, or anonymous classes (since they require an instance).


    Methods:

    Allowed Modifiers:
        Access: public, protected, private, or default.
        Other: static, final, abstract, synchronized, strictfp, native.
    Notes:
        static methods are only allowed in static nested classes, as non-static inner, local, and anonymous classes are instance-based.
        abstract methods require the inner class itself to be abstract.

        abstract methods require the inner class itself to be abstract


    Variables and methods can have final, but no access modifiers (public, private, etc.) since the class is scoped to the block.


anonymous   

    Variables and methods follow standard rules but typically override interface/abstract class methods (e.g., public for interface methods).
No static members (fields or methods) since anonymous classes are instance-based unless in a static context.



Inner Class Type,Class Modifiers,Field Modifiers,Method Modifiers
Non-Static Inner,"public, private, protected, abstract, final, strictfp","public, private, protected, final, transient, volatile","public, private, protected, final, abstract, synchronized, strictfp, native"
Static Nested,"public, private, protected, static, abstract, final, strictfp",Same as above + static,Same as above + static
Local,"final, abstract",final (no access modifiers),"No access modifiers, final, abstract, synchronized, strictfp, native"
Anonymous,None (implicit final),"final, transient, volatile (no static)","public (for interface methods), final, synchronized, strictfp, native (no static)"




new <Interface> ... ; not valid



public V merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)


What will the following code print?

Map<String, Integer> map1 = new HashMap<>();
map1.put("a", 1);
map1.put("b", 1);
map1.merge("b", 1, (i1, i2)->i1+i2);
map1.merge("c", 3, (i1, i2)->i1+i2);
System.out.println(map1);





If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, replaces the associated value with the results of the given remapping function, or removes if the result is null. This method may be of use when combining multiple mapped values for a key. For example, to either create or append a String msg to a value mapping:
  map.merge(key, msg, String::concat)



super.super is an invalid construct.



   var values = new ArrayList<String>();
    Object[] sa = values.toArray(); 
    // String[] sa = values.toArray(); // invalid
    String[] sa = values.toArray(new String[0]); //valid, 
    
    String[] temp = null;
    String[] sa = values.toArray(temp);


just need to put this jar on module-path to make it an automatic modul

