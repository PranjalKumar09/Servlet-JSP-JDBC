List<Subtype> is NOT a subtype of List<Supertype>.
This is crucial for type safety at compile time.

        List<String> stringList = new ArrayList<>();
        stringList.add("Hello");

        // Compile-time error: Incompatible types.
        // List<Object> objectList = stringList; // String is an Object, but List<String> is not List<Object>.
                                                // This prevents accidentally adding a non-String object to stringList via objectList.
        System.out.println(stringList);


  Map<String, List<String>> countryCitiesMap = new HashMap<>();

      List<String> oldList = new ArrayList<String>();

        // Java 7+ with Diamond Operator: Compiler infers <String> from the left side
        List<String> newList = new ArrayList<>();


<? extends Type> (Upper Bounded): Can read Type or its subtypes; cannot add (except null).
<? super Type> (Lower Bounded): Can add Type or its subtypes; reads as Object (requires cast).

    public static void printNumbers(List<? extends Number> list) {
        for (Number num : list) {
            System.out.println(num); // Safe to read as Number
        }
        // list.add(10); // Compile-time error: Cannot add to a List<? extends Number>
    }

    // Method that can add Integers (or its subtypes) to a list of Integer or any supertype of Integer (e.g., Number, Object)
    public static void addIntegers(List<? super Integer> list) {
        list.add(1); // Safe to add Integer
        list.add(2); // Safe to add Integer
        // Integer value = list.get(0); // Compile-time error: Cannot be sure what type is retrieved, needs cast to Object
        System.out.println("List after adding integers: " + list);
    }

        List<Number> numbersList = new ArrayList<>();
        addIntegers(numbersList); // Works because Integer is a subtype of Number

        List<Object> objectList = new ArrayList<>();
        addIntegers(objectList); // Works because Integer is a subtype of Object
    






java.sql.Driver
java.sql.DataSource




You have a collection (say, an ArrayList) which is read by multiple reader threads and which is modified by a single writer thread. The collection allows multiple concurrent reads but does not tolerate concurrent read and write. Which of the following strategies will you use to obtain best performance?

synchronize all access to the collection.? or 
make the collection variable final and volatile.?

no, While this is a valid approach, if you do this then even the reader threads will not be able to read concurrently. This will drastically reduce performance.

Encapsulate the collection into another class and use ReadWriteLock to manage read and write access. => yes

Which of the following are true regarding the Date-Time API of java.time package?
It uses the calendar system defined in ISO-8601 as the default calendar.



java.sql.DriverManager class provides the following three static methods to retrieve a Connection object:

    static Connection getConnection(String url)
    Attempts to establish a connection to the given database URL.

    static Connection getConnection(String url, Properties info)
    Attempts to establish a connection to the given database URL.

    static Connection    getConnection(String url, String user, String password)



What classes can a non-static nested class extend ?
(Provided that the class to be extended is visible and is not final.)
Any class.



A nested class is any class whose declaration occurs within the body of another class or interface.
An inner class is a nested class that is not explicitly or implicitly declared static.

A static nested class can contain a non - static inner class.


map
boolean remove(Object key, Object value)
object remove(Object key)
V putIfAbsent(K key, V value)
Object removeIfPresent(Object key)
boolean replace(K key, V oldValue, V newValue)

 Map providing atomic versions of putIfAbsent, remove, and replace methods. 
