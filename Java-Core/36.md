`

Pattern Matching for instance of
    

    public void order (Prouct p){
        if (p instance of Food f && f.getBestBefore().isBefore(LocalDate.now())){
            LocalDate bestBefore = f.getBestBefore();
        }else {
            // variable oyt fo scope
        }
    }


---

### üîí Sealed Classes and Interfaces in Java

* **Purpose**: Control which classes or interfaces are allowed to extend or implement them.
* **Declared using** `sealed` keyword.

#### ‚úÖ Key Rules:

1. **Only permitted types** (listed via `permits`) can extend/implement a sealed class/interface.
2. Permitted types must:

   * Be in the **same module**, and
   * If in an unnamed module, in the **same package** as the sealed parent.
3. Every permitted subclass must be explicitly declared as:

   * `final` ‚Äì cannot be subclassed further,
   * `sealed` ‚Äì can restrict further subclassing,
   * `non-sealed` ‚Äì allows unrestricted subclassing.

---

### ‚úÖ Example

```java
// Sealed parent class
package shop;
public abstract sealed class Product permits Food, Drink {}

// Permitted subclass 1 - non-sealed (can be extended freely)
package shop;
public non-sealed class Food extends Product {}

// Permitted subclass 2 - final (cannot be extended further)
package shop;
public final class Drink extends Product {}
```

---

### ‚ùå Invalid Example

```java
package shop;
public class Other extends Product {} // ‚ùå Compile-time error
```

**Why?** `Other` is not listed in `permits` clause of `Product`.

---



Java Records
    Immutable & implicitly final data classes
    Require only types & names of fields
    Implicitly extend java.lang.Record class, it is final class
    A record declaration specifies description of its content in header
    Accessors, constructor, equals, hashcode and toString method created automatrically
    can declare nested types, including nested record classes

public record Product(String name, double price){

}

Product p1 = new Product("Tea", 1.99);
Product p2 = new Product("Tea", 1.99);
boolean same = p1.equals(p2);
int hashCode = p1.hashCode();
String name = p1.name();
String text = p1.toString();


Custom Record Constructor
    constructor is generated automatically based on record header
    optionally, custom  constructor may also be created in two styles

    conventoinal
public record Product(String name){
    public Product(String name){
        name = name.toUpperCase();
        this.name = name; 
    }
}

    compact
public record Product(String name){
    public Product{
        name = name.toUpperCase();
    }
}










Factory Method 


