

executeUpdate returns the number of rows that have been affected by the query. Like in insert 1 row effect so ouput is 1





while (false) { x=3; } is a compile-time error because the statement x=3; is not reachable;
Similarly, for( int i = 0; false; i++) x = 3; is also a compile time error because x= 3 is unreachable.





The compiler can only look for compile time constant values to determine whether a piece of code is reachable or not. Therefore, the following is valid:
boolean b = false;
for (int i = 0; b; i++) {x = 3;};//Compiles fine

It is fine because b is a variable and not a compile time constant. If you make b final, it will become a compile time constant and then the above for statement will not compile.



In if(false){ x=3; }, although the body of the condition is unreachable, this is not an error because the JLS explicitly defines this as an exception to the rule. It allows this construct to support optimizations through the conditional compilation. For example,







    Enum constructor is always private. You cannot make it public or protected. If an enum type has no constructor declarations, then a private constructor that takes no parameters is automatically provided.
    An enum is implicitly final, which means you cannot extend it. For the same reason, it cannot be sealed.
    You cannot extend an enum from another enum or class because an enum implicitly extends java.lang.Enum. But an enum can implement interfaces.
    Since enum maintains exactly one instance of its constants, you cannot clone it. You cannot even override the clone method in an enum because java.lang.Enum makes it final.
    Compiler provides an enum with two public static methods automatically - values() and valueOf(String). The values() method returns an array of its constants and valueOf() method tries to match the String argument exactly (i.e. case sensitive) with an enum constant and returns that constant if successful otherwise it throws java.lang.IllegalArgumentException.
    By default, an enum's toString() prints the enum name but you can override it to print anything you want.
    Enum constant declare n starting
    in Enum in constuctior cant acess the  non final static from enum constructor

The following are a few more important facts about java.lang.Enum which you should know:

    It implements java.lang.Comparable (thus, an enum can be added to sorted collections such as SortedSet, TreeSet, and TreeMap). The natural order of the enum values is the order in which they are defined i.e. in the order of their ordinal value.
    enum can implement othger interfface too
    It has a method ordinal(), which returns the index (starting with 0) of that constant i.e. the position of that constant in its enum declaration.
    It has a method name(), which returns the name of this enum constant, exactly as declared in its enum declaration.



NavigableMap<K,V> tailMap(K fromKey, boolean inclusive)
          Returns a view of the portion of this map whose keys are greater than (or equal to, if inclusive is true) fromKey. 






Only methods of an interface can be private. private/protected fields are not allowed.





interface Processor {
   Iterable process();
}

interface ItemProcessor extends Processor{
   Collection process();
}

interface WordProcessor extends Processor{
   String process();
}

interface GenericProcessor extends ItemProcessor, WordProcessor{
    
}


Since Collection interface extends Iterable interface, it is valid for ItemProcessor to override process method with a return type of Collection. This satisfies the rule of "covariant returns", which states that an overriding method is allowed to return a sub type of the return type defined in the overridden method.


WordProcessor fails compilation because it does not override the process method correctly.
String is not a sub type of Iterable, and thus, is not covariant with Iterable. 


GenericProcessor fails compilation because it inherits two process methods with incompatible return types.


The @Override annotation is an optional annotation that can be applied to an overriding method. This annotation ensures that the method really does override a super class's (or interface's) method.

If there is a mistake in the name of the subclass's method or if the parameters don't match the overridden method, then it would become an entirely new method instead of an override. In absence of this annotation, the compiler has no way of knowing whether your intention was to actually create a new method or to override the super type's method and this may cause unexpected behavior at run time, which is difficult to trace. 




hashmap-> key or value anything can null
hashtable allows none , give NullPointerException



void setNull(int parameterIndex, int sqlType)

sqlType: The SQL type of the column (e.g., java.sql.Types.INTEGER, java.sql.Types.VARCHAR, Types.DATE, Types.NULL), defined in java.sql.Types.
or null


parameterIndex - the first parameter is 1, the second is 2, ... throws SQLException 


