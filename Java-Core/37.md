
Generics

without generic we have to use Object but to ensure type safety we use generics
Without generic in object it is risk of replace by any object, it is bulky code

public class ClassName<T> {
    public:
    private T value;
    private T getValue(){
        return value;
    }
}
There can be marker other than T


Some<Product> some = new Some<>();

can we used with class & interface both


like -> public interface Comparable<T>{
    int compareTo(T o);
}

public interface Comparator<T>{
    int compare(T o1, T  o2);
}


// less than -> -ve
// more than -> +ve
// equal -> 0


ex->
public class ProductSorter implements Comparator<Product>{
    public int compare(Product p1, Product p2){
        return p1.getName().compareTo(p2.getName());
    }
}
String, LocalDate, BigDecimal etc already have implmented int compare

genreic cant be applied to 
    * Descendent of Throwable
    * Anonymous classes
    * Enumeration


Some<Product> some = new Some(); compile with warning


Following will compile but no information will available
Some some5 = new Some<Product>();

Some some6 = new Some(); its object type



composition pattern
a class may represent composition of features implemented by different other classes

like
public class Account implements WithDrawing, Depositing ....{
    ....
}public class Bank implements WithDrawing, Depositing. Authentication ....{
    ....
    public Account account;
    public ... methodOfWithDrawing(){
        return account.methodOfWithDrawing();
    }
}

more flexiblity 


sorting in array

java.util.Arrays


public class LengthCompare implements Comparator<String>{
    ---
}

Arrays.sort(name1, name2, new LengthCompare())


in syantax this is correct
int[] values= {2,12,3,5,5};
int sum = 0;
for (int i = 0; i < values.length; sum+=i++);



Arrays.copy(<array>,<new length> )
Arrays.copyOfRange(<array>,<start>, <end>)


Iterable<T> is top level interface that allow  any collection to be used forEach loop
Collection<E> extends iterable &  describe generic capabilities

various class like List<E>, Set<E>, SortedSet<E> , Map<K, V> extend it


# BRANCH: Assuming current branch is 'main' (adjust if needed)

# 1. NEW FILES (2 separate commits)
git add Java-Core/pratice/4/productManagement/src/labs/pm/data/Rateable.java
git commit -m "feat: Add Rateable interface for product rating system" --date "2025-06-26"

git add Java-Core/pratice/4/productManagement/src/labs/pm/data/resources.properties
git commit -m "feat: Add resource bundle for product management i18n" --date "2025-06-20"

# 2. MODIFIED FILES (grouped logically)
# Core concept documentation updates
git add Java-Core/02-oops.md Java-Core/18-core-oop-concepts-inheritance-overloading-overriding.md
git commit -m "docs: Update OOP concepts with polymorphism examples" --date "2025-06-20"

# Flow control and lambda updates
git add Java-Core/14-flow-control.md Java-Core/30-lambda_expressions.md
git commit -m "docs: Enhance flow control and lambda expression examples" --date "2025-06-25"

# Product management system changes
git add Java-Core/pratice/4/productManagement/src/labs/pm/*
git commit -m "refactor: Improve product management core logic" --date "2025-06-24"

# VS Code and untracked file
git add .vscode/settings.json Java-Core/37.md
git commit -m "chore: Update IDE settings and add new core concepts notes" --date "2025-06-22"

# Remaining individual changes
git add Java-Core/04-array.md
git commit -m "docs: Add array sorting benchmarks" --date "2025-06-21"

git add Java-Core/17-java-interface-inheritance-notes.md
git commit -m "docs: Clarify interface default method inheritance" --date "2025-06-23"

git add Java-Core/31-date_time_localization.md
git commit -m "docs: Add timezone conversion examples" --date "2025-06-20"