Collectors.groupingBy

expects 


PreparedStatement supports setObject(int parameterIndex, Object x, int targetSqlType)




Additional Method: CallableStatement supports both:

setObject(int parameterIndex, Object x, int targetSqlType) (inherited from PreparedStatement).
setObject(String parameterName, Object x, int targetSqlType) for named parameters, which is unique to CallableStatement.



CallableStatement inherits from PreparedStatement, therefore, you can use various setXXX methods to set the input values 


Setting parameter values by name is not possible with PreparedStateme





To use the out parameter (assuming that the third parameter is an OUT parameter in this stored procedure), you must first "register" it like this:

stmt.registerOutParameter(3, java.sql.Types.INTEGER);
OR
stmt.registerOutParameter("AMOUNT", java.sql.Types.INTEGER);





while (hasResults) {
   ResultSet rs = stmt.getResultSet();
   // process result set
   hasResults = stmt.getMoreResults();
}



in try with resource, finnaly exception one is suppressed
and in try catch finally ,,, suppressed one is 
 , 




Array initializer needs an explicit target-type because without it, the compiler is not able to deduce the type unambiguously. Therefore, it must be written as:
var array2D = new int[][] { { 0, 1, 2, 4}, {5, 6}};



In question in array must check for comma is there or not



binary Search not need to be ascending, but it need to sorted using comparator, 
if not sorted, result is undefined not error


List<String> letters = new ArrayList<String>();
letters.addAll(List.of("a", "c", "b"));


Collections.reverse(letters);
System.out.println(Collections.binarySearch(letters, "c"));

output -> undefined (unpredictable int value)


but it can produce result if it used sort or like this
 Collections.binarySearch(letters, "c", Comparator.reverseOrder()) //returns 0 



 interface ->
java.sql.Driver
java.sql.Connection
java.sql.Statement

not interface but api ->
java.sql.DriverManager

