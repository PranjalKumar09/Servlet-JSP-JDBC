java.io.Console
readPassword
reader
writer
readLine


read no this is not



.move & .copy dont implement auto closeable interface,  so cant we used in try-with-resourcesO




OptionalDouble print like >>>    OptionalDouble[<double value>]



short to char / vice versa not covert require explicit cast


offer() method

    Adds an element to the rear of the queue if space is available.
    Returns true if the element is successfully added.
    Returns false if the queue is full and cannot accommodate the new element, rather than throwing an exception.



add() method

    Adds an element to the rear of the queue, similar to offer().
    Returns true if the element is successfully added.
    Throws an IllegalStateException if the queue is full and cannot accommodate the new element.




"messages" should be just this not location, or something else

ResourceBundle msg = ResourceBundle.getBundle("messages", new Locale("fr", "FR"))





While StringReader is a valid class but it creates a Reader out of a String. It does not read Strings from a Reader. For example:
StringReader sr = new StringReader("some long string");




 IntStream.of(...)
 it takd int or vararg or ints



 format of jdbc url is jdbc:<subprotocol>:<subname>




 in for loop , if 2nd term is there , it must be boolean






outer class can access inner class private vairable

Non-Static Inner Class: both side can access each other


Static Nested Class: Cannot directly access private instance variables of the enclosing class (needs an instance); the enclosing class can access private variables of the static nested class via an instance.

Local Class: Can access private variables of the enclosing class; the enclosing method can access private variables of the local class via an instance.

Anonymous Class: Can access private variables of the enclosing class; the enclosing method can access private variables of the anonymous class via its interface or superclass type.





When interfaces are involved, more than one method declaration may be overridden by a single overriding declaration. In this case, the overriding declaration must have a throws clause that is compatible with ALL the overridden declarations.
it will intersected situation  in two exception  (parent & chlid) -> implement with child one because this satisfies both



NON RELATIVE EXCEPTION

import java.io.IOException;
import java.sql.SQLException;

// First interface
interface Interface1 {
    void method() throws IOException;
}

// Second interface
interface Interface2 {
    void method() throws SQLException;
}

// Class implementing both interfaces
class MyClass implements Interface1, Interface2 {
    @Override
    public void method() throws IOException, SQLException {
        // Implementation can throw IOException, SQLException, both, or neither
        if (someCondition()) {
            throw new IOException("IO error");
        } else if (someOtherCondition()) {
            throw new SQLException("SQL error");
        }
        System.out.println("Method executed");
    }
}
Specifically, the implemented method can:

Throw no exceptions (i.e., an empty throws clause), as this is compatible with any exception type.
Throw a subset of the exceptions declared by the interfaces (including none).
Throw exceptions that are subtypes of the exceptions declared in the interfaces.


The implemented method cannot throw:

Exceptions that are not declared in at least one of the interfaces’ method signatures.
Broader exceptions (e.g., a superclass of the declared exceptions, like Exception, unless it’s declared in the interfaces).